
<!DOCTYPE html>
<html class="full" lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <!--<link rel="icon" href="../../favicon.ico"> -->

    <title>Parallel Bilateral Filtering</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/justified-nav.css" rel="stylesheet">

    <link rel="stylesheet" id="font-awesome-css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css" media="screen">

    <!--<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script> -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>

    <style>
      p {
        font-size: 15px;
      }
      img {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width:50%;
      }
      form {
        margin-left:18px;
      }
      ol>li {
        font-size:15px;
      }
      .back-to-top {
        position: fixed;
        bottom: 2em;
        right: 0px;
        text-decoration: none;
        color: #000000;
        background-color: rgba(235, 235, 235, 0.80);
        font-size: 12px;
        padding: 1em;
        display: none;
      }

      .back-to-top:hover {    
          background-color: rgba(135, 135, 135, 0.50);
      }
    </style>


    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <a href="#" class="back-to-top">Back to Top</a>

    <div class="container">

      <!-- The justified navigation menu is meant for single line per list item.
           Multiple lines will require custom code not provided by Bootstrap. -->
      <div class="masthead">
        <img src="img/logo.png" style="width:1100px" align="middle">
        <h3 class="text-muted">Parallel Bilateral Filtering using OpenCL</h3>
        <nav>
          <ul class="nav nav-justified">
            <li class="active"><a id="ahome" href="#" data="#home">Home</a></li>
            <li><a id="aintroduction" href="#" data="#introduction">Introduction</a></li>
            <li><a id="amethod" href="#" data="#method">Methods</a></li>
            <li><a id="aresults" href="#" data="#results">Results</a></li>
            <li><a id="aconclusions" href="#" data="#conclusions">Conclusions</a></li>
          </ul>
        </nav>
      </div>


      <div id="home">
        <!-- Jumbotron -->
        <div class="jumbotron">
          <h2>Parallel Bilateral Filtering using OpenCL</h2>
          <p class="lead">Ruitao (Toby) Du, Xide Xia</p>
          <p>CS205: Computing Foundations for Computational Science </p>
          <p>Instructor: Thouis "Ray" Jones </p>
          <p>
            <span class="slogan"></span>
          </p>
          <p><a class="btn btn-lg btn-success" href="https://github.com/xidexia/Bilateral-Filtering/tree/master" role="button" target="_blank">Try Our Code</a></p>
          <center>
            <iframe width="620" height="445" src="https://www.youtube.com/embed/TRVlFCA-YxQ">
            </iframe>
          </center>
        </div>

        <!-- Example row of columns -->
        <div class="row">
          <div class="col-lg-4">
            <h2>OpenCL without buffer</h2>
            <p>Compute a batch of points at the same time with OpenCL to speed up the processing</p>
            <p><a class="btn btn-primary detail" href="#m1" role="button" data="#amethod">View details &raquo;</a></p>
          </div>
          
          <div class="col-lg-4">
            <h2>OpenCL with buffer</h2>
            <p>Further accelerate the calculation by taking advantage of local buffers</p>
            <p><a class="btn btn-primary detail" href="#m2" role="button" data="#amethod">View details &raquo;</a></p>
          </div>

          <div class="col-lg-4">
            <h2>OpenCL with buffer and index trick</h2>
            <p>Use an index trick to reuse part of the buffer of the previous iterations</p>
            <p><a class="btn btn-primary detail" href="#m3" role="button" data="#amethod">View details &raquo;</a></p>
          </div>
        </div>  

      </div>

      <div id="introduction", class="hidden">
        <h2>Project Overview</h2>
        <p>Smoothing is one of the most commonly used image processing methods. Smoothing an image or a data set is to create an approximating function that attempts to capture important patterns in the data while leaving the noise points - the data points of a signal are modified so individual points are reduced and points that are lower than the adjacent points are increased leading to a smoother signal. There are many kinds of image smoothing algorithms such as Gaussian smoothing, Laplace smoothing, and Bilateral smoothing. A bilateral filter is a nonlinear, edge-preserving and noise-reducing smoothing filter for images. However, for high resolution images, it would take a long time to run.</p>

        <p>In this project, our goal is to develop an efficient algorithm for bilateral filtering. In traditional image processing, only one pixel’s value is going to be changed at one time. In our project, we plan to improve efficiency via parallel computing. For example, in the smoothing processing, a predefined filter A is applied to the input image. Traditionally, the center of A is multiplied with the current pixel and the adjacent elements of A are multiplied with the adjacent pixels of the image respectively. With the help of parallel programming in python and OpenCL, we implemented multithreads with local buffers. We also tried some index tricks to further speed up the performance. </p>
        <br>

        <h2>Bilateral Filtering</h2>
        <p>Bilateral Filtering is one of the most fundamental operations of image processing. It smooths images while preserving edges, by means of a nonlinear combination of nearby image values. It is a non-iterative, local, and simple method that combines gray levels or colors based on both their geometric closeness and their photometric similarity, and prefers near values to distant values in both domain and range. The basic method behind bilateral filtering is to update the values of pixels based on their neighborhood. It takes a weighted sum of the pixels in a neighborhood. The values of weights depend on the spatial distance between current pixel to the neighbor as well as depend on the intensity of the pixels. Because of the way the weights are calculated, the bilateral filtering is able to preserve edges while still averaging and getting rid of the noise. </p>
        <img src="img/formula.png" >

        
        Domain Filter:
        <img src="img/1.png" style="width:350px;">
        In order to preserve the normalize the pixel:
        <img src="img/2.png" style="width:200px;">

        Range filtering:
        <img src="img/3.png" style="width:400px;">
        In this case, the kernel measures the intensity similarity between pixels. The normalization constant in this case is:
        <img src="img/4.png"  style="width:300px;">

        Bilateral filtering method combines domain and range filtering. Therefore, combined filtering is:
        <img src="img/5.png"  style="width:450px;">
        with the normalization constant:
         <img src="img/6.png"  style="width:400px;">

        Bilateral filtering method replaces the pixel value at x with a weighed average of similar and nearby pixel values in x's neighborhood. Pixel values in a small neighborhood are similar to each other. It acts essentially as a standard domain filter- it averages away the small, weakly correlated differences between pixel values caused by noise. 
        <img src="img/gaussian.png" style="width:300px;">
        <br>


        <h2>Examples:</h2>

        <img src="img/cat_compare.png">

      </div>


      <div id="method", class="hidden">
        <h2>Methods</h2>
        <p>This project explores different parallel implementations of bilateral filtering in OpenCL and compares the performance of them with the serial version in python. Below are four methods we implemented. In these methods, we all precompute the domain kernel first so that we don't need to calculate them multiple times.</p>
        <br>

        <h3>1. Serial version with NumPy</h3>
        <p>Calculate the output pixel by pixel. For each pixel, we need to calculate the pixel difference within a certain neighborhood. To speed up the process, we vectorize the calculation by utilizing NumPy.</p>
        <br>
        <img src="img/p1.png" style="width:1000px;">
        
        <div id="m1">
          <h3>2. OpenCL version without buffer</h3>
          <p>Calculate the output pixels in blockwise parallel. We use OpenCL with different work group sizes to parallelize the code. Work group sizes are 8×8, 12×12, 16×16, 20×20. Inside the OpenCL code, it directly reads from global memory when we access the neighborhood.</p>
          <br>
          <img src="img/p2.png" style="width:600px;">
        </div>


        <div id="m2">
          <h3>3. OpenCL version with buffer</h3>
          <p>Calculate the output pixels in blockwise parallel. We use OpenCL with different work group size to parallelize the code. Work group sizes are 8×8, 12×12, 16×16, 20×20. Inside the OpenCL code, first we read in all neighborhood of a work group to the buffer. And then we access the neighborhood by reading from local memory. This way can save time on accessing the global memory.</p>
          <br>
          <img src="img/p3.png" style="width:800px;">
        </div>

        <div id="m3">
          <h3>4. OpenCL version with buffer and index trick</h3>
          <p>Calculate the output pixels in columnwise parallel. In previous OpenCL methods, we put some pixels to the buffer multiple times. Work group sizes are 16×8, 20×8, 24×8, 28×8, 20×4, 24×4. Instead, we were reusing the buffer by introducing an index trick. Also, to increase the percentage of reused buffer, we set the work group size to be a long thin rectangle.</p>
          <br>
          <img src="img/p4.png" style="width:700px;">
        </div>

      </div>


      <div id="results", class="hidden">
        <h3>Parameters Used</h3>
        <p>Spatial σ = halo / 2, Intensity σ = 50 pixels </p>
        <p>We use half of the neighborhood size as the spatial sigma because we use gaussian kernel. When the neighbor is two sigma away, the weight should be approximately zero.</p>

        <h3>Machine Used</h3>
        <p>Apple OpenCL version: OpenCL 1.2 </p>
        <p>CPU: Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz</p> 
        <p>Maximum clock Frequency: 2200 MHz </p>
        <p>Maximum allocable memory size: 4294 MB</p> 
        <p>Maximum work group size 1024 </p>
        <p>GPU: Iris Pro Maximum clock Frequency: 1200 MHz </p>
        <p>Maximum allocable memory size: 402 MB </p>
        <p>Maximum work group size 512 .</p>
        <br>
        <br>

        <h3>Outputs</h3>
        <p> To show the performance of our Bilateral Filtering, we used several different images to test. Following is the output image result of different size of neighborhood:</p>
        <p>We can see that as the size of neighborhood increases, the image is more blurred. This is because we average the pixel value across more points.</p>
        <img src="img/cat.png" style="width:1100px; height:700px;">
        <br>

        <h3>Run Time Comparison</h3>

        <h4>Serial vs. Parallel</h4>
        <p>Serial version is much slower than the parallel one. Even though we calculate a small neighborhood, serial version still takes a few seconds to run while parallel one just takes 0.3 second. Therefore, our OpenCL version is much faster than the serial version. However, we want to further explore our parallel version</p>
        <img src="img/r0.png" style="width:580px; height:550px;">
        <br>

        <h4>Workgroup</h4>
        <h5>Without Buffer</h5>
        <p>In our machine, best workgroup is 16 by 16. There is something interesting in the graph. 8 by 8 is very fast when neighborhood is small. However, we can see that after size of 8, the run time rises dramatically. We think it is because small workgroup will seperate the picture into more blocks. When neighborhood size increases, the run time for each block increase in a complexity of N^2. Therefore, if we have more blocks, run time will also increase more.</p>
        <img src="img/r1.png" style="width:600px;">
        <br>

        <h5>With Buffer</h5>
        <p>This plot is similar to the without buffer one. Best work group size is still 16 by 16.</p>
        <img src="img/r2.png" style="width:600px;">
        <br>
        <h5>With Buffer and Index Trick</h5>
        <p>Best work group size is still 20 by 8.</p>
        <img src="img/r3.png" style="width:600px;">
        <br>

        <h4>Methods Comparison</h4>
        <p> From the results, we see a larger neighborhood requires more runtime. It also shows parallel versions are much faster than the serial version. Within the three OpenCL versions, the result shows that using local buffers will save more runtime than using the global memory. However, when we add an index trick, the processing slows down. That’s because although the index trick helps to reuse part of the buffer of previous iterations, it requires extra time to calculate the index and less total number of threads.</p>
        <img src="img/r4.png" style="width:600px;">

        
      </div>

      <div id="conclusions", class="hidden">
        <h3>Conclusions</h3>
        <p>Bilateral Filtering is one of the most fundamental operations of image processing. From our output, we can see that it can preserve edges and get rid of the noise of our images. In our machine and our sample images, the best method to speed up the bilateral filtering is the OpenCL version with buffer with a work group size of 16 by 16. When the halo size is 10, it takes about 2.5 seconds to finish the filter. This method outperforms the serial version a lot.</p>

        <p>In the future, we can further explore more parallel algorithm such as using CUDA to see which is faster. Also we can speed up the process of other image filtering algorithm with similar parallelized methods.</p>

        <h3>Resource</h3>

        <p> Watch our screencast? <a href="https://www.youtube.com/watch?v=TRVlFCA-YxQ" target="_blank">Youtube</a></p>
        <p> Get our codes? <a href="https://github.com/xidexia/Bilateral-Filtering/tree/master" target="_blank">Github</a></p>
        <br>

        <h3>Reference</h3>
        <p>1. Paris, Sylvain, et al. "A gentle introduction to bilateral filtering and its applications." ACM SIGGRAPH 2007 courses. ACM, 2007.</p>
        <p>2. Paris, Sylvain, et al. Bilateral filtering: Theory and applications. Now Publishers Inc, 2009.</p>
        <p>3. OpenCL, Khronos. "The open standard for parallel programming of heterogeneous systems." Website. URL http://www. khronos. org/opencl. Symposium on Microarchitecture, MICRO.</p>
        <br>

        <h3>Acknowledgements</h3>
        <p>We thank Ray and all CS205 TFs for providing the wonderful course and all helpful instructions.</p>
        <p>This work was done as part of the CS205 course at Harvard. You can find more information and other cool projects here: <a href="http://iacs-courses.seas.harvard.edu/courses/cs205/" target="_blank">CS205</a></p>
        <br>

        <h3>Contact information</h3>
        <p>Toby Du: ruitaodu at g.harvard.edu</p>
        <p>Xide Xia: xidexia at g.harvard.edu</p>

      </div>



      <!-- Site footer -->
      <footer class="footer">
        <p>&copy; Du, Xia</p>
      </footer>

    </div> <!-- /container -->


    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="js/ie10-viewport-bug-workaround.js"></script>
    <script type="text/javascript">
      $("ul.nav-justified li").each(function() {
        $(this).on("click", function() {
          var cur_href = $("li.active > a").attr('data');
          $(cur_href).addClass('hidden')
          $('ul.nav-justified li.active').removeClass('active')
          $(this).addClass('active')
          //var cur_href = $("li.active").attr('href');
          var cur_href = $("li.active>a").attr('data');
          //alert(cur_href);
          $(cur_href).removeClass("hidden");
        // Toggle classes of divs
        });
      });

      $(".detail").each(function() {
        $(this).on("click", function() {
          var cur_href = $("li.active > a").attr('data');
          
          $(cur_href).addClass('hidden')
          $('ul.nav-justified li.active').removeClass('active')

          var cur_href = $(this).attr('data');
          //alert(("a"+cur_href));
          $("a"+cur_href).parent().addClass('active')
          //var cur_href = $("li.active").attr('href');
          var cur_href = $("li.active>a").attr('data');
          //alert(cur_href);
          $(cur_href).removeClass("hidden");
        // Toggle classes of divs
        });
      });

      jQuery(document).ready(function() {
        var offset = 220;
        var duration = 500;
        jQuery(window).scroll(function() {
            if (jQuery(this).scrollTop() > offset) {
                jQuery('.back-to-top').fadeIn(duration);
            } else {
                jQuery('.back-to-top').fadeOut(duration);
            }
        });
        
        jQuery('.back-to-top').click(function(event) {
            event.preventDefault();
            jQuery('html, body').animate({scrollTop: 0}, duration);
            return false;
        })
      });
    </script>
    

    <!-- <script src="js/jquery.js"></script> -->
    <script src="js/typed.min.js"></script>
    <script>
      $(function(){
        $(".slogan").typed({
          strings: ["Want to smooth your picture?", "Your filter is too slow?","Speed it up with OpenCL!"],
          typeSpeed: 20,
          loop: true
        });
      });
    </script>

  </body>
</html>
