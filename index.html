
<!DOCTYPE html>
<html class="full" lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <!--<link rel="icon" href="../../favicon.ico"> -->

    <title>TextMining</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/justified-nav.css" rel="stylesheet">

    <link rel="stylesheet" id="font-awesome-css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css" media="screen">

    <!--<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script> -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>

    <style>
      p {
        font-size: 15px;
      }
      img {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width:50%;
      }
      form {
        margin-left:18px;
      }
      ol>li {
        font-size:15px;
      }
      .back-to-top {
        position: fixed;
        bottom: 2em;
        right: 0px;
        text-decoration: none;
        color: #000000;
        background-color: rgba(235, 235, 235, 0.80);
        font-size: 12px;
        padding: 1em;
        display: none;
      }

      .back-to-top:hover {    
          background-color: rgba(135, 135, 135, 0.50);
      }
    </style>


    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <a href="#" class="back-to-top">Back to Top</a>

    <div class="container">

      <!-- The justified navigation menu is meant for single line per list item.
           Multiple lines will require custom code not provided by Bootstrap. -->
      <div class="masthead">
        <img src="img/logo.png" style="width:1100px" align="middle">
        <h3 class="text-muted">Parallel Bilateral Filtering using OpenCL</h3>
        <nav>
          <ul class="nav nav-justified">
            <li class="active"><a id="ahome" href="#" data="#home">Home</a></li>
            <li><a id="aintroduction" href="#" data="#introduction">Introduction</a></li>
            <li><a id="amethod" href="#" data="#method">Methods</a></li>
            <li><a id="aresults" href="#" data="#results">Results</a></li>
            <li><a id="aconclusions" href="#" data="#conclusions">Conclusions</a></li>
          </ul>
        </nav>
      </div>


      <div id="home">
        <!-- Jumbotron -->
        <div class="jumbotron">
          <h2>Parallel Bilateral Filtering using OpenCL</h2>
          <p class="lead">Ruitao (Toby) Du, Xide Xia</p>
          <p>CS205: Computing Foundations for Computational Science </p>
          <p>Instructor: Thouis "Ray" Jones </p>
          <p>
            <span class="slogan"></span>
          </p>
          <p><a class="btn btn-lg btn-success" href="https://github.com/xidexia/Bilateral-Filtering/tree/master" role="button" target="_blank">Try Our Code</a></p>
          <center>
            <iframe width="620" height="445" src="https://www.youtube.com/embed/TRVlFCA-YxQ">
            </iframe>
          </center>
        </div>

        <!-- Example row of columns -->
        <div class="row">
          <div class="col-lg-4">
            <h2>OpenCL without buffer</h2>
            <p>Compute a batch of points at the same time with OpenCL to speed up the processing</p>
            <p><a class="btn btn-primary detail" href="#m1" role="button" data="#amethod">View details &raquo;</a></p>
          </div>
          
          <div class="col-lg-4">
            <h2>OpenCL with buffer</h2>
            <p>Further accelerate the calculation by taking advantage of local buffers</p>
            <p><a class="btn btn-primary detail" href="#m2" role="button" data="#amethod">View details &raquo;</a></p>
          </div>

          <div class="col-lg-4">
            <h2>OpenCL with buffer and index trick</h2>
            <p>Use an index trick to reuse part of the buffer of the previous iterations</p>
            <p><a class="btn btn-primary detail" href="#m3" role="button" data="#amethod">View details &raquo;</a></p>
          </div>
        </div>  

      </div>

      <div id="introduction", class="hidden">
        <h1>Project Overview</h1>
        <p>Smoothing is one of the most commonly used image processing methods. To smooth an image or a data set is to create an approximating function that attempts to capture important patterns in the data while leaving the noise points - the data points of a signal are modified so individual points are reduced and points that are lower than the adjacent points are increased leading to a smoother signal. There are many kinds of image smoothing algorithms such as gaussian smoothing, laplace smoothing, and bilateral smoothing. A bilateral filter is a nonlinear, edge-preserving and noise-reducing smoothing filter for images. However, for high resolution images, it would take a long time to run.  It is important that image is processed and analyzed using image processing algorithms at minimum cost. By parallelizing of the algorithm, we can optimize the speed at which the image is processed. This project explores the parallel implementation of. The main objective of this project is to design som bilateral filtering. This parallel algorithm will be able to work with different number of threads and to take all the benefits of the processors.</p>
        <p>In this project, our goal is to develop an efficient algorithm for bilateral filtering. In traditional image processings, image filtering are applied to exert various effects on photos. The center of a selected filter matrix has to be multiplied with the current pixel, the other elements of the filter matrix with corresponding neighbor pixels. In other words, only one pixel’s value is going to be changed at one time. In our project, we plan to improve efficiency via parallel computing. For example, in the smoothing processing, a predefined filter A is applied to the input image. Traditionally, the center of A is multiplied with the current pixel and the adjacent elements of A are multiplied with the adjacent pixels of the image respectively. Then we replace the current pixel’s value with the average of the sum of the multiplication we just calculated before moving to the next pixel. With the help of parallel programming in python and cython, we can try multithreading and spark to boost the performance by updating pixels block by block. </p>

        <h1>Bilateral Filtering</h1>
        <p>Bilateral Filtering is one of the most fundamental operations of image processing. It smooths images while preserving edges, by means of a nonlinear combination of nearby image values. It is a non-iterative, local, and simple method that combines gray levels or colors based on both their geometric closeness and their photometric similarity, and prefers near values to distant values in both domain and range. The basic method behind bilateral filtering is to do update the values of pixels based on their neighborhood. It takes a weighted sum of the pixels in a neighborhood. The values of weights depend on the spatial distance between current pixel to the neighbor as well as on the intensity of the pixels. Because of the way the weights are calculated, the bilateral filtering is able to preserve edges while still averaging and getting rid of the noise. </p>
        <img src="img/formula.png" >

        

        Consider a shift-invariant low-pass domain filter applied to an image:
        <img src="img/1.png" style="width:350px; height:60px;">

        The bold font for f and h emphasizes the fact that both input and output images may be multi-band. In order to preserve the DC component, it must be:
        <img src="img/2.png" style="width:200px; height:55px;">


        Range filtering is similarly defined:
        <img src="img/3.png" style="width:400px; height:60px;">


        In this case, the kernel measures the photometric similarity between pixels. The normalization constant in this case is:
        <img src="img/4.png"  style="width:300px; height:60px;">

        Bilateral filtering method combines domain and range filtering, thereby enforcing both geometric and photometric locality. Combined filtering can be described as follows:
        <img src="img/5.png"  style="width:450px; height:60px;">

        with the normalization:
         <img src="img/6.png"  style="width:400px; height:60px;">

        Bilateral filtering method  replaces the pixel value at x with a weighed average of similar and nearby pixel values in x's neighborhood. Pixel values in a small neighborhood are similar to each other. It acts essentially as a standard domain filter- it averages away the small, weakly correlated differences between pixel values caused by noise. 
        <img src="img/gaussian.png" style="width:300px; height:300px;">
        <img src="img/0.gif" style="width:1000px; height:300px;">


        <h3>Examples:</h3>

        <img src="img/cat.jpg">
        


      </div>


      <div id="method", class="hidden">
        <h2>Methods</h2>
        <p>This project explores different parallel implementations of bilateral filtering in OpenCL and compares the performance of them with the serial version in python. Below is four methods we implemented. In these methods, we all precompute the spatial difference first so that we don't need to calculate them multiple times.</p>
        <br>

        <h3>1. Serial version with NumPy</h3>
        <p>Calculate the output pixel by pixel. For each pixel, we need to calculate the pixel difference within a certain neighborhood. To speed up the process, we vectorize the calculation by utilizing NumPy.</p>
        <br>
        <img src="img/p1.png" style="width:1000px; height:400px;">
        
        <div id="m1">
          <h3>2. OpenCL version without buffer</h3>
          <p>Calculate the output pixels in blockwise parallel. We use OpenCL with different work group size to parallelize the code. Work group sizes are 8×8, 12×12, 16×16, 20×20. Inside the OpenCl code, it directly read from global memory when we access the neighborhood.</p>
          <br>
          <img src="img/p2.png" style="width:600px; height:600px;">
        </div>


        <div id="m2">
          <h3>3. OpenCL version with buffer</h3>
          <p>Calculate the output pixels in blockwise parallel. We use OpenCL with different work group size to parallelize the code. Work group sizes are 8×8, 12×12, 16×16, 20×20. Inside the OpenCL code, first we read in all neighborhood of a work group to the buffer. And then we access the neighborhood by reading from local memory. This way can save time on accessing the global memory.</p>
          <br>
          <img src="img/p3.png" style="width:800px; height:700px;">
        </div>

        <div id="m3">
          <h3>4. OpenCL version with buffer and index trick</h3>
          <p>Calculate the output pixels in columnwise parallel. In previous OpenCL methods, we put some pixels to the buffer multiple times. Work group sizes are 16×8, 20×8, 24×8, 28×8, 20×4, 24×4. Instead, we were reusing the buffer by introducing an index trick. Also, to increase the percentage of reused buffer, we set the work group size to be a long thin rectangle.</p>
          <br>
          <img src="img/p4.png" style="width:700px; height:700px;">
        </div>

        <h2>Machine Used</h2>
        <p>Apple OpenCL version: OpenCL 1.2 </p>
        <p>CPU: Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz</p> 
        <p>Maximum clock Frequency: 2200 MHz </p>
        <p>Maximum allocable memory size: 4294 MB</p> 
        <p>Maximum work group size 1024 </p>
        <p>GPU: Iris Pro Maximum clock Frequency: 1200 MHz </p>
        <p>Maximum allocable memory size: 402 MB </p>
        <p>Maximum work group size 512 .</p>
        <br>

      </div>


      <div id="results", class="hidden">
        <h2>Results</h2>
        <br>

        <h2>Parallel Bilateral Filtering in OpenCL</h2>
        <br>

        <h3>Outputs</h3>
        <p> To show the performance of our Bilater Filtering processing, we used several different images to test. Following is the output image result of different size of neighborhood:</p>
        <br>

        <img src="img/cat.png" style="width:1100px; height:700px;">

        <h3>Runtime</h3>
        <br>

        <h4>Serial vs. Parallel</h4>
        <br>
        <img src="img/r0.png" style="width:580px; height:550px;">

        <h4>Workgroup</h4>
        <br>
        <img src="img/r1.png" style="width:600px; height:600px;">
        <img src="img/r2.png" style="width:600px; height:600px;">
        <img src="img/r3.png" style="width:600px; height:600px;">
        <img src="img/r4.png" style="width:600px; height:600px;">

        <p> From the results, we see a larger neighborhood requires more runtime. It also shows parallel versions are much faster than the serial version. Within the three OpenCL versions, the result shows that using local buffers will save more runtime than using the global memory. However, when we add an index trick, the processing slows down. That’s because although the index trick helps to reuse part of the buffer of previous iterations, it requires extra time to calculate the index and less total number of threads.</p>


        
      </div>

      <div id="conclusions", class="hidden">
        <h2>Conclusions</h2>
        <p>Bilateral Filtering is one of the most fundamental operations of image processing. In a bilateral filter, there is a spatial filter that measures the geometric closeness between the current point and a nearby point. There is another filter called intensity filter that measures the photometric similarity between the pixel value of the current point and that of a nearby point. Bilateral filtering combines the spatial and intensity filters, thereby enforcing both geometric and photometric locality. </p>

        <p>In our project, we explored different parallel implementations of bilateral filtering in openCL and compared their performances with the serial version in python: First, we tried serial version with NumPy. Second, we compute a batch of points at the same time with OpenCL to speed up the processing. Third, with OpenCL, we further accelerate the calculation by taking advantage of local buffers to save time of accessing the global memory. Since for some points, we are accessing their pixel value for multiple times. We finally use an index trick to reuse part of the buffer of the previous iterations.</p>

        <h2>Resource</h2>

        <p> Watch ouor screencast? <a href="https://www.youtube.com/watch?v=TRVlFCA-YxQ" target="_blank">Youtube</a></p>
        <p> Get our codes? <a href="https://github.com/xidexia/Bilateral-Filtering/tree/master" target="_blank">Github</a></p>
        <br>

        <h3>Reference</h3>
        <p>1. Paris, Sylvain, et al. "A gentle introduction to bilateral filtering and its applications." ACM SIGGRAPH 2007 courses. ACM, 2007.</p>
        <p>2. Paris, Sylvain, et al. Bilateral filtering: Theory and applications. Now Publishers Inc, 2009.</p>
        <p>3. OpenCL, Khronos. "The open standard for parallel programming of heterogeneous systems." Website. URL http://www. khronos. org/opencl. Symposium on Microarchitecture, MICRO.</p>
        <br>

        <h3>Acknowledgements</h3>
        <p>We thank Ray and all CS205 TFs for providing the wonderful course and all helpful instructions.</p>
        <p>This work was done as part of the CS205 course at Harvard. You can find more information and other cool projects here: <a href="http://iacs-courses.seas.harvard.edu/courses/cs205/" target="_blank">CS205</a></p>
        <br>

        <h3>Contact information</h3>
        <p>Toby Du: ruitaodu at g.harvard.edu</p>
        <p>Xide Xia: xidexia at g.harvard.edu</p>

      </div>



      <!-- Site footer -->
      <footer class="footer">
        <p>&copy; Du, Xia</p>
      </footer>

    </div> <!-- /container -->


    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="js/ie10-viewport-bug-workaround.js"></script>
    <script type="text/javascript">
      $("ul.nav-justified li").each(function() {
        $(this).on("click", function() {
          var cur_href = $("li.active > a").attr('data');
          $(cur_href).addClass('hidden')
          $('ul.nav-justified li.active').removeClass('active')
          $(this).addClass('active')
          //var cur_href = $("li.active").attr('href');
          var cur_href = $("li.active>a").attr('data');
          //alert(cur_href);
          $(cur_href).removeClass("hidden");
        // Toggle classes of divs
        });
      });

      $(".detail").each(function() {
        $(this).on("click", function() {
          var cur_href = $("li.active > a").attr('data');
          
          $(cur_href).addClass('hidden')
          $('ul.nav-justified li.active').removeClass('active')

          var cur_href = $(this).attr('data');
          //alert(("a"+cur_href));
          $("a"+cur_href).parent().addClass('active')
          //var cur_href = $("li.active").attr('href');
          var cur_href = $("li.active>a").attr('data');
          //alert(cur_href);
          $(cur_href).removeClass("hidden");
        // Toggle classes of divs
        });
      });

      jQuery(document).ready(function() {
        var offset = 220;
        var duration = 500;
        jQuery(window).scroll(function() {
            if (jQuery(this).scrollTop() > offset) {
                jQuery('.back-to-top').fadeIn(duration);
            } else {
                jQuery('.back-to-top').fadeOut(duration);
            }
        });
        
        jQuery('.back-to-top').click(function(event) {
            event.preventDefault();
            jQuery('html, body').animate({scrollTop: 0}, duration);
            return false;
        })
      });
    </script>
    

    <!-- <script src="js/jquery.js"></script> -->
    <script src="js/typed.min.js"></script>
    <script>
      $(function(){
        $(".slogan").typed({
          strings: ["Need a bilateral filter?", "Your filter is too slow?","Speed it up with OpenCL!"],
          typeSpeed: 20,
          loop: true
        });
      });
    </script>

  </body>
</html>
